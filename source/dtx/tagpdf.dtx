% \iffalse meta-comment
%
%% File: tagpdf.dtx
%
% Copyright (C) 2019-2020 Ulrike Fischer
%
% It may be distributed and/or modified under the conditions of the
% LaTeX Project Public License (LPPL), either version 1.3c of this
% license or (at your option) any later version.  The latest version
% of this license is in the file
%
%    https://www.latex-project.org/lppl.txt
%
% This file is part of the "tagpdf bundle" (The Work in LPPL)
% and all files in that bundle must be distributed together.
%
% -----------------------------------------------------------------------
%
% The development version of the bundle can be found at
%
%    https://github.com/u-fischer/tagpdf
%
% for those people who are interested.
%
% \fi
%
% \begin{implementation}
% \section{Initialization and test if pdfmanagement is active.}
%    \begin{macrocode}
%<@@=tag>
%<*package>
\ProvidesExplPackage {tagpdf} {2021-06-14} {0.82}
  { A package to experiment with pdf tagging }

\bool_if:nF
  {
    \bool_lazy_and_p:nn
      {\cs_if_exist_p:N \pdfmanagement_if_active_p:}
      { \pdfmanagement_if_active_p: }
  }
  {  %error for now, perhaps warning later.
    \PackageError{tagpdf}
     {
       PDF~resource~management~is~no~active!\MessageBreak
       tagpdf~will~no~work.
     }
     {
       Activate~it~with \MessageBreak
       \string\RequirePackage{pdfmanagement-testphase}\MessageBreak
       \string\DeclareDocumentMetadata{<options>}\MessageBreak
       before~\string\documentclass
     }
  }
%    \end{macrocode}
% We map the internal module name \enquote{tag} to \enquote{tagpdf} in messages.
%    \begin{macrocode}
\prop_if_exist:NT \g_msg_module_name_prop
  {
    \prop_gput:Nnn \g_msg_module_name_prop { tag }{ tagpdf }
  }
%    \end{macrocode}
%\section{Package options}
% There are only two options to switch for luatex between generic and luamode,
% TODO try to get rid of them.
%    \begin{macrocode}
\bool_new:N\g_@@_mode_lua_bool
\DeclareOption {luamode}    { \sys_if_engine_luatex:T { \bool_gset_true:N \g_@@_mode_lua_bool } }
\DeclareOption {genericmode}{ \bool_gset_false:N\g_@@_mode_lua_bool }
\ExecuteOptions{luamode}
\ProcessOptions
%    \end{macrocode}
% \end{macro}
% \section{Packages}
% We need the temporary version of l3ref until this is in the kernel.
%    \begin{macrocode}
\RequirePackage{l3ref-tmp}
%    \end{macrocode}
% \end{macro}
% \section{Temporary code}
% This is code which will be removed when proper support exists in LaTeX
% \subsection{a LastPage label}
% See also issue \#2 in Accessible-xref
% \begin{macro}{\@@_lastpagelabel:}
%    \begin{macrocode}
 \cs_new_protected:Npn \@@_lastpagelabel:
   {
     \legacy_if:nT { @filesw }
       {
         \exp_args:NNnx \exp_args:NNx\iow_now:Nn \@auxout
            {
              \token_to_str:N \newlabeldata
                {@@_LastPage}
                {
                  {abspage} { \int_use:N \g_shipout_readonly_int}
                  {tagmcabs}{ \int_use:N \c@g_@@_MCID_abs_int }
                }
            }
       }
   }

 \AddToHook{enddocument/afterlastpage}
  {\@@_lastpagelabel:}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\ref_value:nnn}
% This allows to locally set a default value if the label or the attribute
% doesn't exist.
% See issue \#4 in Accessible-xref.
% \begin{syntax}
% \cs{ref_value:nnn}\Arg{label}\Arg{attribute}\Arg{Fallback default}
% \end{syntax}
%    \begin{macrocode}
 \cs_if_exist:NF \ref_value:nnn
   {
     \cs_new:Npn \ref_value:nnn #1#2#3
       {
         \exp_args:Nee
           \__ref_value:nnn
            { \tl_to_str:n {#1} } { \tl_to_str:n {#2} } {#3}
       }
     \cs_new:Npn \__ref_value:nnn #1#2#3
       {
         \tl_if_exist:cTF { g__ref_label_ #1 _ #2 _tl }
           { \tl_use:c { g__ref_label_ #1 _ #2 _tl } }
           {
             #3
           }
       }
   }
%    \end{macrocode}
% \end{macro}
% \section{Variables}
% \begin{macro}
%  {
%    \l_@@_tmpa_tl,
%    \l_@@_tmpa_str,
%    \l_@@_tmpa_prop,
%    \l_@@_tmpa_seq,
%    \l_@@_tmpb_seq,
%    \l_@@_tmpa_clist,
%    \l_@@_tmpa_int
%  }
% A few temporary variables
%    \begin{macrocode}
\tl_new:N    \l_@@_tmpa_tl
\str_new:N   \l_@@_tmpa_str
\prop_new:N  \l_@@_tmpa_prop
\seq_new:N   \l_@@_tmpa_seq
\seq_new:N   \l_@@_tmpb_seq
\clist_new:N \l_@@_tmpa_clist
\int_new:N   \l_@@_tmpa_int
%    \end{macrocode}
% Attribute lists for the label command. We have a list for
% mc-related labels, and one for structures.
% \begin{macro}{\c_@@_refmc_clist,\c_@@_refstruct_clist}
%    \begin{macrocode}
\clist_const:Nn \c_@@_refmc_clist     {tagabspage,tagmcabs,tagmcid}
\clist_const:Nn \c_@@_refstruct_clist {tagstruct,tagstructobj}
%    \end{macrocode}
% \end{macro}
%
% \begin{variable}{\l_@@_loglevel_int}
% This integer hold the log-level and so allows to
% control the messages.
% TODO: a list which log-level shows what is needed. The current behaviour
% is quite ad-hoc.
%    \begin{macrocode}
\int_new:N  \l_@@_loglevel_int
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}
%  {
%    \g_@@_active_mc_bool,
%    \g_@@_active_tree_bool,
%    \g_@@_active_struct_bool
%  }
% These booleans should help to control the global behaviour of tagpdf.
% Ideally it should do nothing if all are false.
% The mc-boolean activates \cs{tag_mc_begin:n},
% the tree-boolean activates writing the finish code and the pdfmanagement related
% commands, the struct boolean actives the storing of the structure data.
% In a normal document all should be active, the split is only there for
% debugging purpose.
% Also we assume currently that they are set only at begin document. But
% if some control passing over groups are needed they could be perhaps
% used in a document too.
% TODO: check if they are used everywhere as needed and as wanted.
%    \begin{macrocode}
\bool_new:N \g_@@_active_mc_bool
\bool_new:N \g_@@_active_tree_bool
\bool_new:N \g_@@_active_struct_bool
%    \end{macrocode}
% \end{variable}

% \begin{variable}
%  {
%    \l_@@_active_mc_bool,
%    \l_@@_active_struct_bool
%  }
% These booleans should help to control the \empht{local} behaviour of tagpdf.
% In some cases it could e.g. be necessary to stop tagging completely.
% As local booleans they respect groups.
% TODO: check if they are used everywhere as needed and as wanted.
%    \begin{macrocode}
\bool_new:N \l_@@_active_mc_bool
\bool_set_true:N \l_@@_active_mc_bool
\bool_new:N \l_@@_active_struct_bool
\bool_set_true:N \l_@@_active_struct_bool
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\g_@@_tagunmarked_bool}
% This boolean controls if the code should try to automatically
% tag parts not in mc-chunk. It is currently only used in luamode.
% It would be possible to used it in generic mode, but this would create
% quite a lot empty artifact mc-chunks.
%    \begin{macrocode}
\bool_new:N \g_@@_tagunmarked_bool
%    \end{macrocode}
% \end{variable}
%
% \section{Variants of l3 commands}
%     \begin{macrocode}
\prg_generate_conditional_variant:Nnn \pdf_object_if_exist:n {e}{T,F}
\cs_generate_variant:Nn \pdf_object_ref:n {e}
\cs_generate_variant:Nn \pdfannot_dict_put:nnn {nnx}
\cs_generate_variant:Nn \pdffile_embed_stream:nnn {nxx,oxx}
\cs_generate_variant:Nn \prop_gput:Nnn {Nxx}
\cs_generate_variant:Nn \prop_put:Nnn  {Nxx}
\cs_generate_variant:Nn \ref_label:nn { nv }
\cs_generate_variant:Nn \seq_set_split:Nnn{Nne}
\cs_generate_variant:Nn \str_set_convert:Nnnn {Nonn, Noon, Nnon }
%    \end{macrocode}

% \section{Setup label attributes}
% \begin{macro}{tagstruct,tagstructobj,tagabspage,tagmcabs,tagmcid}
% This are attributes used by the label/ref system.
% With structures we store the structure number |tagstruct|
% and the object reference |tagstructobj|.
% The second is needed to be able to reference a structure which hasn't been
% created yet. The alternative would be to create the object in such cases,
% but then we need to check the object existence all the time.
%
% With mc-chunks we store the absolute page number |tagabspage|,
% the absolute id |tagmcabc|, and the id on the page |tagmcid|.
%    \begin{macrocode}
\ref_attribute_gset:nnnn { tagstruct } {0} { now }
  { \int_use:N \c@g_@@_struct_abs_int }
\ref_attribute_gset:nnnn { tagstructobj } {} { now }
  {
    \pdf_object_if_exist:eT {@@/struct/\int_use:N \c@g__tag_struct_abs_int}
      {
        \pdf_object_ref:e{@@/struct/\int_use:N \c@g_@@_struct_abs_int}
      }
  }
\ref_attribute_gset:nnnn { tagabspage } {0} { shipout }
  { \int_use:N \g_shipout_readonly_int }
\ref_attribute_gset:nnnn { tagmcabs } {0} { now }
  { \int_use:N \c@g_@@_MCID_abs_int }
\ref_attribute_gset:nnnn {tagmcid }  {0} { now }
  { \int_use:N \g_@@_MCID_tmp_bypage_int }
%    \end{macrocode}
% \end{macro}
%    \begin{macrocode}
%=================
% command to set a label
%================
\cs_new_protected:Npn \@@_ref_label:nn #1 #2 %#1 label, #2 name of list mc or struct
  {
    \@bsphack
    \ref_label:nv {#1}{c_@@_ref#2_clist}
    \@esphack
  }
%==============
% command to retrieve the value
%===============
\cs_new:Npn \@@_ref_value:nnn #1 #2 #3 %#1 label, #2 attribute, #3 default
  {
    \ref_value:nnn {#1}{#2}{#3}
  }
%===============
% the LastPage label has a different name, so we need a special command for now
% =============
\cs_new:Npn \@@_ref_value_lastpage:nn #1 #2
  {
    \ref_value:nnn {@@_LastPage}{#1}{#2}
  }

% as ref doesn't expand label names we need variants:
\cs_generate_variant:Nn \@@_ref_label:nn {en}
\cs_generate_variant:Nn \@@_ref_value:nnn {enn}

%    \end{macrocode}
%
%
% \section{Keys for tagpdfsetup}
% TODO: checks need to be improved
%    \begin{macrocode}


\keys_define:nn { @@ / setup }
  {
    activate-mc     .bool_gset:N = \g_@@_active_mc_bool,
    activate-tree   .bool_gset:N = \g_@@_active_tree_bool,
    activate-struct .bool_gset:N = \g_@@_active_struct_bool,
    activate-all    .meta:n = {activate-mc,activate-tree,activate-struct},
    activate        .meta:n = {activate-mc,activate-tree,activate-struct},
    log             .choice:,
    log / none      .code:n = {\int_set:Nn \l_@@_loglevel_int { 0 }},
    log / v         .code:n = {\int_set:Nn \l_@@_loglevel_int { 1 }},
    log / vv        .code:n = {\int_set:Nn \l_@@_loglevel_int { 2 }},
    log / vvv       .code:n = {\int_set:Nn \l_@@_loglevel_int { 3 }},
    log / all       .code:n = {\int_set:Nn \l_@@_loglevel_int { 10 }},
    tagunmarked     .bool_gset:N = \g_@@_tagunmarked_bool,
    tagunmarked     .initial:n  = true,
    tabsorder       .choice:,
    tabsorder / row       .code:n =
      \pdfmanagement_add:nnn { Page } {Tabs}{/R},
    tabsorder / column    .code:n =
      \pdfmanagement_add:nnn { Page } {Tabs}{/C},
    tabsorder / structure .code:n =
      \pdfmanagement_add:nnn { Page } {Tabs}{/S},
    tabsorder / none      .code:n =
      \pdfmanagement_remove:nn {Page} {Tabs},
    tabsorder       .initial:n = structure,
    uncompress      .code:n = { \pdf_uncompress:  },
    global-mc .code:n =
      {
        \cs_set_eq:NN\@@_attribute_set:Nn \@@_attribute_gset:Nn
        \cs_set_eq:NN\@@_attribute_unset:N\@@_attribute_gunset:N
      }
  }
%need to think about the right place ...

\hook_gput_code:nnn{begindocument}{tagpdf}
  {
    \keys_define:nn { @@ / setup }
     {
       global-mc .code:n={}
     }
  }
% escape commands are a bit engine specific so have been moved to the backend files.
% commands to escape strings so that they can be safely used in pdf
% currently not much used. But will be needed later, when alt and actualtext are added.
%escape command. They are backend specific as \pdf@escapehex would ignore most chars
%outside the "pdflatex" range

% These commands are only aliases for most engines but
% are defined differently with luatex
% to get also lua tables.
\sys_if_engine_luatex:TF
  {
    \file_input:n {tagpdf-luatex.def}
  }
  {
    \cs_set_eq:NN \@@_prop_new:N        \prop_new:N
    \cs_set_eq:NN \@@_seq_new:N         \seq_new:N
    \cs_set_eq:NN \@@_prop_gput:Nnn     \prop_gput:Nnn
    \cs_set_eq:NN \@@_seq_gput_right:Nn \seq_gput_right:Nn
    \cs_set_eq:NN \@@_seq_item:cn       \seq_item:cn
    \cs_set_eq:NN \@@_prop_item:cn      \prop_item:cn
    \cs_set_eq:NN \@@_seq_show:N        \seq_show:N
    \cs_set_eq:NN \@@_prop_show:N       \prop_show:N
  }

\cs_generate_variant:Nn \@@_prop_gput:Nnn      { Nxn , Nxx, Nnx , cnn, cxn, cnx, cno}
\cs_generate_variant:Nn \@@_seq_gput_right:Nn  { Nx  , No, cn, cx }
\cs_generate_variant:Nn \@@_prop_new:N   { c }
\cs_generate_variant:Nn \@@_seq_new:N    { c }
\cs_generate_variant:Nn \@@_seq_show:N   { c }
\cs_generate_variant:Nn \@@_prop_show:N  { c }

%% Loading the tagpdf sub packages
\RequirePackage { tagpdf-checks-code }
\RequirePackage { tagpdf-user }
\RequirePackage { tagpdf-tree-code }
\RequirePackage { tagpdf-roles-code }
\RequirePackage { tagpdf-attr-code }
% mc-code is split:
\RequirePackage { tagpdf-mc-code-shared }
\bool_if:NTF \g_@@_mode_lua_bool
  {
   \RequirePackage {tagpdf-mc-code-lua}
  }
  {
   \RequirePackage { tagpdf-mc-code-generic } %
  }

\RequirePackage { tagpdf-struct-code }
\RequirePackage { tagpdf-space-code }
%</package>
%    \end{macrocode}
%
%    \begin{macrocode}
%<*user>
\ProvidesExplPackage {tagpdf-user} {2021-06-14} {0.82}
  {tagpdf - user commands}
%    \end{macrocode}

% \begin{macro}{\tagpdfsetup}
%    \begin{macrocode}
\NewDocumentCommand \tagpdfsetup { m }
  {
    \keys_set:nn { @@ / setup } { #1 }
  }

\cs_set_eq:NN\tagpdfifluatexTF \sys_if_engine_luatex:TF
\cs_set_eq:NN\tagpdfifluatexT  \sys_if_engine_luatex:T
\cs_set_eq:NN\tagpdfifpdftexT  \sys_if_engine_pdftex:T
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\tag_if_active:}
% This is a test it tagging is active. This allows packages
% to add conditional code. We probably will need a better
% test in the end, but for now it should be ok.
%    \begin{macrocode}
\prg_new_conditional:Npnn \tag_if_active: { p , T , TF, F }
  {
     \bool_if:NTF\g_@@_active_struct_bool
       {
         \prg_return_true:
       }
       {
         \prg_return_false:
       }
  }
%    \end{macrocode}
% \end{macro}
%
% We need a command to stop tagging in some places.
%
% \begin{macro}{ \tag_stop_group_begin:, \tag_stop_group_end: }
%    \begin{macrocode}
\bool_new:N \l_@@_stop_bool

\prg_new_conditional:Nnn \@@_if_stop: {p,T,F,TF}
  {
    \bool_if:NTF \l_@@_stop_bool
      { \prg_return_true:  }
      { \prg_return_false: }
  }

\prg_new_eq_conditional:NNn \tag_if_stop: \@@_if_stop: {p,T,F,TF}

\cs_new_protected:Npn \@@_stop:
  {
    \bool_set_true:N \l_@@_stop_bool
    \cs_set_eq:NN \tag_mc_begin:n     \use_none:n
    \cs_set_eq:NN \tag_mc_end:        \prg_do_nothing:
    \cs_set_eq:NN \tag_mc_use:n       \use_none:n
    \cs_set_eq:NN \tag_struct_begin:n \use_none:n
    \cs_set_eq:NN \tag_struct_end:    \prg_do_nothing:
    \cs_set_eq:NN \tag_struct_use:n   \use_none:n
  }

\cs_new_protected:Npn \tag_stop_group_begin:
  {
    \group_begin:
    \@@_stop:
  }

\cs_set_eq:NN \tag_stop_group_end: \group_end:
%    \end{macrocode}
% \end{macro}
% We need a command to stop tagging in some places.
%
% \begin{macro}{ \tagpdfget, \tag_get:n  }
% This is a generic command to retrieve data. Currently
% the only sensible value for the argument is |mc_tag|
%    \begin{macrocode}
\cs_new:Npn \tagpdfget #1   { \use:c {@@_get_data_#1: } }
\cs_new:Npn \tag_get:n #1   { \use:c {@@_get_data_#1: } }

%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tagmcifinTF}
% This is a test if an mc is open or not. It is mostly of
% importance for pdflatex as lualatex doesn't mind much if a mc tag is not
% correctly closed.
%    \begin{macrocode}
\NewDocumentCommand \tagmcifinTF { m m }
  {
    \@@_mc_if_in:TF { #1 } { #2 }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{tagmcartifact}
%    \begin{macrocode}
\NewDocumentEnvironment{tagmcartifact}{m}
 {
  \tag_mc_artifact_group_begin:n { #1}\ignorespaces
 }
 {
  \tag_mc_artifact_group_end:
 }

%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tagmcbegin,\tagmcend,\tagmcuse  }
%    \begin{macrocode}
\NewDocumentCommand \tagmcbegin { m }
  {
    \tag_mc_begin:n {#1}\ignorespaces
  }


\NewDocumentCommand \tagmcend {  }
  {
    \if_mode_horizontal: \unskip \fi: %
    \tag_mc_end:
  }

\NewDocumentCommand \tagmcuse { m }
  {
    \tag_mc_use:n {#1}
  }

%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tagstructbegin,\tagstructend,\tagstructuse  }
%
% These are structure related user commands
%    \begin{macrocode}
\NewDocumentCommand \tagstructbegin { m }
  {
    \tag_struct_begin:n {#1}
  }

\NewDocumentCommand \tagstructend {  }
  {
   \tag_struct_end:
  }

\NewDocumentCommand \tagstructuse { m }
  {
    \tag_struct_use:n {#1}
  }

%    \end{macrocode}
% \end{macro}
%
% \section{Debugging}
%
% \begin{macro}{\showtagpdfmcdata,\showtagpdfattributes }
% This commands are lua only
%    \begin{macrocode}
\NewDocumentCommand\showtagpdfmcdata { O {\@@_tag_get_mc_abs_cnt:} }
  {
    \bool_if:NT \g_@@_mode_lua_bool
      {
        \sys_if_engine_luatex:T
          {
            \lua_now:e{ltx.@@.trace.show_all_mc_data(#1)}
          }
      }
  }

\NewDocumentCommand\showtagpdfattributes { }
  {
    \bool_if:NT \g_@@_mode_lua_bool
      {
        \sys_if_engine_luatex:T
          {
            \lua_now:e
              {
                ltx.@@.trace.log
                 (
                   "showtagpdfattributes:
                    MC=>abscnt=\@@_get_mc_abs_cnt:
                    =>attr=\the\l_@@_mc_cnt_attr=>tag="
                    ..
                    tostring(ltx.@@.func.get_tag_from (\the\l_@@_mc_type_attr))
                    ..
                    "=\the\l_@@_mc_type_attr",0
                 )
             }
            \ignorespaces
          }
      }
   }

\NewDocumentCommand\showtagstack {}
  {
    \seq_show:N \g_@@_struct_tag_stack_seq
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{  }
%    \begin{macrocode}
\sys_if_engine_luatex:T
  {
    \NewDocumentCommand\pdffakespace { }
      {
        \@@_fakespace:
      }
  }
%    \end{macrocode}
% \end{macro}
% \section{Paratagging}
%  The following are some simple commands to enable/disable paratagging.
%  Probably one should add some checks if we are already in a paragraph.
%    \begin{macrocode}
\bool_new:N \l_@@_para_bool
\bool_new:N \l_@@_para_show_bool
\int_new:N \g_@@_para_int

\keys_define:nn { @@ / setup }
  {
    paratagging      .bool_set:N = \l_@@_para_bool,
    paratagging-show .bool_set:N = \l_@@_para_show_bool,
  }

\AddToHook{para/begin}
  {
   \int_gincr:N \g_@@_para_int
   \bool_if:NT \l__tag_para_bool
     {
       \tag_struct_begin:n {tag=P}
       \bool_if:NT \l_@@_para_show_bool
        { \tag_mc_begin:n{artifact}
          \llap{\color_select:n{red}\tiny\int_use:N\g_@@_para_int\ }
          \tag_mc_end:
        }
       \tag_mc_begin:n {tag=P}
     }
  }
\AddToHook{para/end}
  {
    \bool_if:NT \l__tag_para_bool
      {
        \tag_mc_end:
        \bool_if:NT \l_@@_para_show_bool
          { \tag_mc_begin:n{artifact}
            \rlap{\color_select:n{red}\tiny\ \int_use:N\g_@@_para_int}
            \tag_mc_end:
          }
        \tag_struct_end:
      }
  }


\newcommand\tagpdfparaOn {\bool_set_true:N \l__tag_para_bool}
\newcommand\tagpdfparaOff{\bool_set_false:N \l__tag_para_bool}

%    \end{macrocode}
% \section{Links}
% We need to close and reopen mc-chunks around links.
% With luatex the push/pop command must be outside groups,
% so we add also code to the generic commands in the hyperref driver.
%    \begin{macrocode}
\hook_gput_code:nnn
  {pdfannot/link/URI/before}
  {tagpdf}
  {
    \tag_mc_end_push:
    \tag_struct_begin:n { tag=Link }
    \tag_mc_begin:n { tag=Link }
    \pdfannot_dict_put:nnx
      { link/URI }
      { StructParent }
      { \tag_struct_parent_int: }
  }

\hook_gput_code:nnn
  {pdfannot/link/URI/after}
  {tagpdf}
  {
     \tag_struct_insert_annot:xx {\pdfannot_link_ref_last:}{\tag_struct_parent_int:}
     \tag_mc_end:
     \tag_struct_end:
     \tag_mc_begin_pop:n{}
  }

\hook_gput_code:nnn
  {pdfannot/link/GoTo/before}
  {tagpdf}
  {
     \tag_mc_end_push:
     \tag_struct_begin:n{tag=Link}
     \tag_mc_begin:n{tag=Link}
     \pdfannot_dict_put:nnx
       { link/GoTo }
       { StructParent }
       { \tag_struct_parent_int: }
  }

\hook_gput_code:nnn
  {pdfannot/link/GoTo/after}
  {tagpdf}
  {
    \tag_struct_insert_annot:xx {\pdfannot_link_ref_last:}{\tag_struct_parent_int:}
    \tag_mc_end:
    \tag_struct_end:
    \tag_mc_begin_pop:n{}

  }

\hook_gput_code:nnn
 {cmd/url/before}
 {tagpdf}
 {\tag_mc_end_push:}

\hook_gput_code:nnn
 {cmd/url/after}
 {tagpdf}
 {\tag_mc_begin_pop:n{}}

\hook_gput_code:nnn
 {cmd/href/before}
 {tagpdf}
 {\tag_mc_end_push:}

\hook_gput_code:nnn
 {cmd/href/after}
 {tagpdf}
 {\tag_mc_begin_pop:n{}}

\hook_gput_code:nnn
 {cmd/hrefurl/before}
 {tagpdf}
 {\tag_mc_end_push:}

\hook_gput_code:nnn
 {cmd/hrefurl/after}
 {tagpdf}
 {\tag_mc_begin_pop:n{}}

%this will go when references are improved
\hook_gput_code:nnn
 {cmd/T@ref/before}
 {tagpdf}
 {\tag_mc_end_push:}

\hook_gput_code:nnn
 {cmd/T@ref/after}
 {tagpdf}
 {\tag_mc_begin_pop:n{}}

\hook_gput_code:nnn
 {cmd/T@pageref/before}
 {tagpdf}
 {\tag_mc_end_push:}

\hook_gput_code:nnn
 {cmd/T@pageref/after}
 {tagpdf}
 {\tag_mc_begin_pop:n{}}

\hook_gput_code:nnn
 {cmd/T@nameref/before}
 {tagpdf}
 {\tag_mc_end_push:}

\hook_gput_code:nnn
 {cmd/T@nameref/after}
 {tagpdf}
 {\tag_mc_begin_pop:n{}}
% "alternative descriptions " for PAX3. How to get better text here??
\pdfannot_dict_put:nnn
 { link/URI }
 { Contents }
 { (url) }

\pdfannot_dict_put:nnn
 { link/GoTo }
 { Contents }
 { (ref) }

%    \end{macrocode}
%</user>
%
